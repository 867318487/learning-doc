# 浏览器缓存
## 浏览器缓存类型
1. 强缓存：浏览器请求某一资源时，会先获取该资源缓存的header信息，然后根据header中的Cache-Control和Expires来判断是否过期。若没过期则直接从缓存中获取资源信息，包括缓存的header的信息，所以此次==请求不会与服务器进行通信==。返回状态码 200 (from memory cache)或200 (from disk cache)。
2. 协商缓存：==向服务器发送请求==，服务器会根据这个请求的参数判断是否命中缓存。如果命中缓存，则返回304状态码并带上新的header通知浏览器从缓存中读取资源。


## 强缓存
### Cache-Control
==Cache-Control是 http1.1 时出现的header信息==，主要是利用该字段的max-age值来进行判断，它是一个相对时间，例如Cache-Control:max-age=3600，代表着资源的有效期是3600秒。

几个常用值
- max-age（单位为s）指定设置缓存最大的有效时间，定义的是时间长短
- no-cache 指定不缓存响应，表明资源不进行缓存。但是设置了no-cache之后并不代表浏览器不缓存，而==是在缓存前要向服务器确认资源是否被更改==。如果浏览器返回304，那么就还是会取浏览器上的缓存。因此有的时候只设置no-cache防止缓存还是不够保险，还可以加上private指令，将过期时间设为过去的时间。
- no-store 绝对禁止缓存。每次请求资源都要从服务器重新获取

### Expires
==Expires是http1.0的规==范，它的值是==一个绝对时间的GMT格式的时间字符串==。比如 ：expires:Fri, 14 Apr 2017 10:47:02 GMT。这个时间代表这这个资源的失效时间，==只要发送请求时间是在Expires之前，那么本地缓存始终有效==，则在缓存中读取数据。缺点：==当服务器与客户端时间偏差较大时，就会导致缓存混乱==。

 **注意： Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高**。

## 协商缓存
### Last-Modify/If-Modify-Since
浏览器第一次请求一个资源的时候，**服务器返回的header中会加上Last-Modify**，Last-modify是一个时间标识该资源的最后修改时间，例如Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。
当浏览器再次请求该资源时，**request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify**。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。
如果命中缓存，则返回304，并且不会返回资源内容和Last-Modify。

### ETag/If-None-Match
Etag/If-None-Match返回的是一个校验码（Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的）。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据浏览器上送的If-None-Match值来判断是否命中缓存。
与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，**由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化**。

两者区别
1. 在精度上，ETag优于Last-Modified。Last-Modified的单位是秒，如果某个文件在1秒内改变了很多次，那么Last-Modified无法体现。ETag每次都会改变。
2. 性能上ETag逊于Last-Modified，ETag计算需要时间。
3. 优先级上，服务器优先考虑ETag。

**注意： Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。**


## 用户行为影响

缓存类型| 获取资源形式| 状态码 | 发送请求到服务器
---|---|---|---
强缓存 | 从缓存取| 200 | 否，直接从缓存取
协商缓存 | 从缓存取| 304 | 是，通过服务端判断是否命中缓存

## 用户行为对缓存的影响

用户操作 | 强缓存| 协商缓存
---|---|---
地址栏回车 | 有效| 有效
页面链接跳转 | 有效 | 有效
新打开窗口 | 有效| 有效
前进后退 | 有效 | 有效
F5刷新 | 无效 | 有效
Ctrl+F5强制刷新 | 无效 | 无效

缓存机制优先级
- Expires < Cache:max-age
- Last-Modified < ETag

## 补充
### webkit的资源分类
- 主资源：比==如HTML页面，或者下载项==，对应代码中的类是MainResourceLoader。可以认为是地址栏url对应的那个资源。
- 派生资源：比如HTML页面中==内嵌的图片或者脚本链接==(js,css)，对应代码中的类是SubresourceLoader。即主资源页面加载的其他资源。

#### 200 (from memory cache)
不访问服务器，直接读缓存，从内存中读取缓存。此时的数据时缓存到内存中的，当kill进程后，也就是浏览器关闭以后，数据将不存在。

==这种方式只适用于派生资源。== 也就是主HTML页面中内嵌页的其他资源，==比如css，js 等等。 不包括这个主页面==。
#### 200 (from disk cache)
不访问服务器，直接从磁盘中读取缓存，当kill进程时，数据还是存在
==这种方式也只能缓存派生资源==。

举个例子就是：
访问-> 200 -> 退出浏览器
再进来-> 200(from disk cache) -> 刷新 -> 200(from memory cache)

普通刷新会启用协商缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存，这也是为什么有时候我们更新一张图片、一个js文件，页面内容依然是旧的，但是直接浏览器访问那个图片或文件，看到的内容却是新的， 因为直接访问是属于主资源的，这时候是不能用强缓存的，只能用协商缓存。

参考链接
- [浅谈之-浏览器缓存](https://kebingzao.com/2018/07/05/browser-cache/)